(*% This program defines the "pure" functions which return the value % of pursuing each of the possible housing options available at time LifePosn for % a given state. % FindBest requires several ambient variables to be defined.*)If[VerboseOutput == True,Print["Running FindViaFOC.m"]];FindViaFOC[[LifePosn]] =Block[{ xt      = #[[xtInPos]],PermInc = #[[PermIncInPos]],QState  = #[[QStateInPos]],EmpState= #[[EmpStateInPos]]},  If[xt < xmin,      (* then punish them for violating the liquidity constraint *)        RiskySharet=ct=st=et=0;        vt= AvoidLikePlague,      (* else find the optimum *)          FOCResults =               FindRoot[                  c == CertEquiv[xt-c,PermInc,QState,EmpState,LifePosn]              ,{c,{xmin+epsilon, xt}}];          If[Length[FOCResults]>2,Print["FOCResults of improper form; probably FindRoot failed."];Interrupt[]];          ct = (c /. FOCResults);          If[Not[NumberQ[ct]], (* then *) Print["FindViaFOC failed."];Print[##];Interrupt[]];           htEnd = htStart*(1-catchup/htScaleFactor)+catchup ct;          st = xt-ct;If[st < 0,st=0;ct=xt;(*#Print["Error in ChoiceBasic: st < 0"];Print[##];Interrupt[]#*)];          RiskySharet=RiskySharetFOC[xt-ct,htEnd,QState,EmpState,LifePosn];    ]; (* End If[xt > xmin] *)ct ] &;