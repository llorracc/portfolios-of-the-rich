(* % Defines all of the baseline parameter values and    % converts them to per period rates where necessary *)Print["Reading in the baseline parameter values."];SolutionMethod = FOC;  (* Can solve either via Value function or via FOCs or Both; FOCs is much better *)rho = 6.;            (* Coefficient of relative risk aversion                     *)gamma = .75;         (* Parameter that governs the strength of habit formation in utility *)catchup = .25;       (* Parameter that governs how quickly habits catch up to consumption *)YearsOfLife    = 80; (* For finite-horizon version, life starts at age 20 and ends at 100 *)PeriodsPerYear = 1;  (* 1 for annual, 4 for quarterly, 12 for monthly (AS IF!)   *)LifeLength  = YearsOfLife*PeriodsPerYear;FirstPeriod = 1;etSig  = .10;        (* Standard deviation of the lognormally distributed component of the transitory earnings shock *)epSig  = .10;        (* Standard deviation of the lognormally distributed permanent income shock *)Cutoff = 3;          (* How many standard deviations above and below the mean to truncate the income shock distributions *)etZeroProb = 0.005;  (* The probability of a zero-income event *)NumOfetVals = 5;     (* Number of points in the discrete approximation to the transitory shock *)NumOfepVals = 5;     (* Number of poitns in the discrete approximation to the permanent shock *)RSig = .157;         (* The standard deviation of the rate of return on the risky asset *)RCutoff = 3;         (* How many standard deviations off to cut off the distribution of R *)NumOfRVals   = 5;    (* Number of points in the discrete approximation to the rate-of-return shock *)EquityPremium=.0425; (* How much higher is the rate of return on equities than the certain rate? *)NumOfRSteps = 6;     (* How many possible portfolio shares to consider? *)NumOfAggStates = 1;  (* For now, consider a model without aggregate shocks *)NumOfEmpStates = 1;  (* Also consider without unemployment spells *)EmpStateProb = {{{1.}}};EmpStateTransitionMatrix = {{{1.}}};CumEmpStateTransitionMatrix = EmpStateTransitionMatrix;SolveForRiskyShare = True;InterpOrder = 1;                        (* % Order of interpolation in the interpolating functions; 1 is linear *)Boom = 1;            (* Indicator that the aggregate state is a high-employment expansion *)Bust = 2;            (* Indicator that the aggregate state is a contraction               *)PostBust = 3;        (* Indicator that the aggregate state is just after a contraction    *)(* % Each of the three aggregate states has a different growth rate of    % permanent income and degree of labor income uncertainty   *)BoomGrowth     = 1.03;BustGrowth     = BoomGrowth;PostBustGrowth = BoomGrowth;(* % Interest rates and growth rates are different for each agg state *)(* Rannual = Gannual = Table[{},{NumOfAggStates}]; *)Rannual = Table[{},{NumOfRVals}];Gannual = Table[{},{NumOfAggStates}]; Rcertain = 1.02;{Rannual,Rprob} = DiscreteApproxToMeanOneLogNormalWithCutoff[RCutoff,RSig,NumOfRVals];Rannual = (Rcertain+EquityPremium) Rannual;Rannual = (Rannual-.1*.01)/.99; Rannual = Prepend[Rannual,.1];Rprob = .99 Rprob;Rprob = Prepend[Rprob,.01];NumOfRVals++;<<life_cycle.m;Rannual = Table[Rannual,{NumOfAggStates}];Rprob   = Table[Rprob  ,{NumOfAggStates}];(* Convert annual flow variables to per-period rates *)G      = Gannual^(1/PeriodsPerYear);            (* Growth rates by aggregate state                        *)R      = Rannual^(1/PeriodsPerYear);            (* Interest rates by aggregate state                      *) m      = (1+mannual)^(1/PeriodsPerYear)-1;      (* Mortgage payment                                       *)n      = (1+nannual)^(1/PeriodsPerYear)-1;      (* Home maintenance expenditures                          *)lambda = (1+lambdaannual)^(1/PeriodsPerYear)-1; (* Flow of housing services per unit of housing stock     *)delta  = (1+deltaannual)^(1/PeriodsPerYear)-1;  (* Depreciation rate on housing                           *)beta   = betaannual^(1/PeriodsPerYear);         (* Time preference discount factor                        *)phi    = phiannual*PeriodsPerYear;              (* Size of new house relative to period income            *)q      = 1.0;                                   (* Price of rental housing compared to user cost of owned *)DiscountR = 1.25^(1/PeriodsPerYear);  	(* Rate at which future income is discounted *)(* % Add epsilon to consumption and housing in utility function    % so that u(0,0) is not -Infinity *)(* epsilon=.1;  *)epsilon=.0001;(* Set up the limits and the grid density for the state variables *)(* % cash-on-hand limits *)(* make xmax  =  5. * PeriodsPerYear if doing annual *)xmin  =  0.;xmax  =  8. * PeriodsPerYear;NumOfxSteps = 15;(* # habit limits   *)hmin  = .5;hmax  = 1.5;NumOfhSteps = NumOfxSteps;hsupermax = xmax*100;(* % savings limits *)smin  = 0.;smax  = xmax;NumOfsSteps = NumOfxSteps;(* % The AggStateTransitionMatrix goves the probabilities of moving to    % each aggregate state tomorrow given a current aggregate state today   % (based on empirical evidence - see table in paper *)(* AggStateTransitionMatrix = {{.95,.05,0},{.05,.7,.25},{.25,.05,.7}};*)(*AggStateTransitionMatrix = {{1/3,1/3,1/3},{1/3,1/3,1/3},{1/3,1/3,1/3}} //N;CumAggStateTransitionMatrix = {{1/3,2/3,1},{1/3,2/3,1},{1/3,2/3,1}} //N;*)AggStateTransitionMatrix = {{1}};CumAggStateTransitionMatrix = {{1}};RStateTransitionMatrix = Rprob;CumRStateTransitionMatrix =   Table[    CumulativeSums[Rprob[[LoopOverAggStates]]]  ,{LoopOverAggStates,NumOfAggStates}];LowMem = False;  (* Determines whether the low-memory version of the programs is run *)VerboseSetup = False; (* Determines how much printing happens *)PositiveFunc = "+";NegativeFunc = "-";