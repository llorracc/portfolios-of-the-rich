(*% This file defines functions which return the values of the expected value function% and of the controls as a function of the state variables at any point in time using% the approximate functions created by interpolation. % The following are defined- %	EtVtp1Raw%	EtVtp1%	Vt		%	Choicet - the homeownership choice%	CtOpt	- non-housing consumption%	ZtOpt	- housing services consumption%	htOpt	- house value %	stOpt 	- savings #           RiskySharetOpt - optimal fraction of savings to invest in the risky asset*)(* % Calculate the expected value of Vtp1 *)ClearAll[EtVtp1Raw];EtVtp1Raw[st_,htEnd_,AggState_,EmpState_,RiskySharet_,LifePosn_] :=(*If[RiskySharet<0 || RiskySharet>1,       (* If they are trying an illegitimate portfolio share            *)  GreatBadness,                          (* then punish them; this imposes the portfolio share constraint *)                                         (* else they are trying a legitimate portfolio share, so proceed *)*)    Sum[            (* over possible rates of return                       *)     Sum[           (* over possible future employment states              *)      Sum[          (* over possible future aggregate states               *)       Sum[         (* over possible future values of the permanent shock  *)        Sum[        (* over possible future values of the transitory shock *)            (G[[LifePosn+1,LoopOverAggStates]] epVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOverepVals]])^(1-rho) *           Vt[             {             ((R[[LoopOverAggStates,LoopOverRVals]]*RiskySharet+Rcertain*(1-RiskySharet))/              (epVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOverepVals]] G[[LifePosn+1,LoopOverAggStates]]))st                  +etVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOveretVals]]             ,htEnd             ,LoopOverAggStates             ,LoopOverEmpStates             ,epVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOverepVals]]             ,LifePosn+1             }            ]                                                                    (* end Vt *)          *etProb[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOveretVals]]        ,{LoopOveretVals,Length[etVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates]]]}] (* End loop over etVals     *)         *epProb[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates,LoopOverepVals]]       ,{LoopOverepVals,Length[epVals[[LifePosn+1,LoopOverAggStates,LoopOverEmpStates]]]}]  (* End loop over epVals     *)        *Rprob[[LoopOverAggStates,LoopOverRVals]]      ,{LoopOverRVals,NumOfRVals}]                                               (* End loop over RStates *)       *EmpStateProb[AggState,EmpState,LoopOverEmpStates]     ,{LoopOverEmpStates,NumOfEmpStates}]                                        (* End loop over EmpStates  *)      *AggStateProb[AggState,LoopOverAggStates]    ,{LoopOverAggStates,NumOfAggStates}]                                         (* End loop over AggStates  *)(*];*)EtVtp1Raw[EtVtp1StateList_] := EtVtp1Raw[EtVtp1StateList[[stEtVtp1Pos]]                                     ,EtVtp1StateList[[htEndEtVtp1Pos]]                                     ,EtVtp1StateList[[AggStateEtVtp1Pos]]                                     ,EtVtp1StateList[[EmpStateEtVtp1Pos ]]                                     ,EtVtp1StateList[[RiskyShareEtVtp1Pos]]                                     ,EtVtp1StateList[[LifePosnEtVtp1Pos ]]                                     ];ClearAll[EtVtp1];EtVtp1[st_,htEnd_,AggState_,EmpState_,RiskySharet_,LifePosn_] := Block[{},If[RiskySharet<0 || RiskySharet>1,   (* If they're trying an illegal portfolio share *)  (* then punish them *)     GreatBadness,  (* else proceed *)    If[st<smin,                    (* If they are trying to save less than the minimum amount ... *)      (* then *)        GreatBadness,              (* Then punish them; this is how the liquidity constraint is imposed *)      (* else *)        If[LifePosn<LifeLength,    (* If this is not the last period of life *)          If[st<sGrid[[1]] && st>0,            (* If saving is too small, use real EtVtp1 *)               Return[EtVtp1Raw[st,htEnd,AggState,EmpState,RiskySharet,LifePosn]],             (* else  use the interpolating function, so long as it doesn't predict positive utility (which can happen because of                the extrapolation if you evaluate the function at a level of wealth far enough above the maximum) *)            Min[EtVtp1InterpFunc[[LifePosn]][st,htEnd,AggState,EmpState,RiskySharet],0]            ],        (* else *) -(RiskySharet)^2      (* This is the last period of life, so the value of saving is zero; # quadratic in RiskyShare causes optimal value to equal zero *)          ] (* end If LifePosn<LifeLength *)      ] (* end If st<smin *)  ] (* End If[RiskyShare Bad] *)];EtVtp1[EtVtp1StateList_]    :=    EtVtp1[EtVtp1StateList[[stEtVtp1Pos]]                                     ,EtVtp1StateList[[htEndEtVtp1Pos]]                                     ,EtVtp1StateList[[AggStateEtVtp1Pos]]                                     ,EtVtp1StateList[[EmpStateEtVtp1Pos ]]                                     ,EtVtp1StateList[[RiskyShareEtVtp1Pos ]]                                     ,EtVtp1StateList[[LifePosnEtVtp1Pos ]]                                     ];ClearAll[Phit];Phit[st_,htEnd_,AggState_,EmpState_,LifePosn_] := Block[{},  If[LifePosn>=LifeLength,     (* then *) 0,    (* else *)    PhitInterpFunc[[LifePosn]][st,htEnd,AggState,EmpState]    ]];Phit[PhitStateList_]    :=    Phit[PhitStateList[[stPhitPos]]                                     ,PhitStateList[[htEndPhitPos]]                                     ,PhitStateList[[AggStatePhitPos]]                                     ,PhitStateList[[EmpStatePhitPos ]]                                     ,PhitStateList[[LifePosnPhitPos ]]                                     ];Clear[Vt];Vt[xt_,htStart_,AggState_,EmpState_,epDrawt_,LifePosn_] := Block[{},If[xt   <= xmin,      (* If they have arrived in this period with assets less than the minimum allowed amount *)  (* then *) GreatBadness,      (* then punish them                                         *)  (* else *)         (* else proceed normally                                    *)    If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved,PeriodOfOptimalRule = LifePosn];     If[LifePosn>=LifeLength,                           (* If it's the last period of life or later                               *)      (* then *)         If[LifePosn == LifeLength,          (* then *) ((xt htStart^-gamma G[[LifePosn,AggState]] epDrawt)^(1-rho))/(1-rho) (* if LifePosn>LifeLength *),          (* else LifePosn > LifeLength so somehow we're being asked to evaluate after the last period of life; set Vt = 0 *)0],      (* else it's earlier than the last period of life *)       Min[0,VtInterpFunc[[LifePosn]][xt,htStart,AggState,EmpState,epDrawt]]    ] (* End If[LifePosn>=LifeLength] *)  ]   (* End If[xt < xmin]            *)]; (* End of Block *)Vt[listinput_] := Vt[                               listinput[[xtVtPos]]                              ,listinput[[htStartVtPos]]                              ,listinput[[AggStateVtPos]]                              ,listinput[[EmpStateVtPos]]                              ,listinput[[epDrawtVtPos]]                              ,listinput[[LifePosnVtPos]]                              ];ClearAll[Choicet];Choicet[xt_,htStart_,AggState_,EmpState_,epDrawt_,LifePosn_] := Block[{},  xarg=xt;(*#  If[xt>xmax,xarg=xmax+(xarg-xmax)/2];*)  harg=htStart;(*#  If[harg>hsupermax,harg=hsupermax+(harg-hsupermax)/2];*)  PeriodOfOptimalRule = LifePosn;  If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved];  ChoicetInterpFunc[[PeriodOfOptimalRule]][xarg,harg,AggState,EmpState,epDrawt]];Choicet[listinput_] := Choicet[                               listinput[[xtVtPos]]                              ,listinput[[htStartVtPos]]                              ,listinput[[AggStateVtPos]]                              ,listinput[[EmpStateVtPos]]                              ,listinput[[epDrawtVtPos]]                              ,listinput[[LifePosnVtPos]]                              ];ClearAll[ctOpt];ctOpt[xt_,htStart_,AggState_,EmpState_,epDrawt_,LifePosn_] := Block[{},  xarg=xt;(*#  If[xt>xmax,xarg=xmax+(xarg-xmax)/2]; #*)  harg=htStart;(*#  If[harg>hsupermax,harg=hsupermax+(harg-hsupermax)/2]; *)  PeriodOfOptimalRule = LifePosn;  If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved];   ctOptInterpFunc[[PeriodOfOptimalRule]][xarg,harg,AggState,EmpState,epDrawt]];ctOpt[listinput_] := ctOpt[                               listinput[[xtVtPos]]                              ,listinput[[htStartVtPos]]                              ,listinput[[AggStateVtPos]]                              ,listinput[[EmpStateVtPos]]                              ,listinput[[epDrawtVtPos]]                              ,listinput[[LifePosnVtPos]]                              ];ClearAll[RiskySharetOpt];RiskySharetOpt[st_,htStart_,AggState_,EmpState_,LifePosn_] := Block[{},  If[st>0,      PeriodOfOptimalRule = LifePosn;      If[LifePosn < EarliestPeriodEtVtp1,PeriodOfOptimalRule = EarliestPeriodEtVtp1];       RiskyInterp = RiskySharetOptInterpFunc[[PeriodOfOptimalRule]][st,htStart,AggState,EmpState];      If[RiskyInterp>1,(* then *) RiskyInterp=1];      If[RiskyInterp<0,(* then *) RiskyInterp=0];      RiskyInterp    (* else they have zero savings and so the Risky Share is meaningless *)    ,Null]];RiskySharetOpt[listinput_] := RiskySharetOpt[                               listinput[[stPhitPos]]                              ,listinput[[htEndPhitPos]]                              ,listinput[[AggStatePhitPos]]                              ,listinput[[EmpStatePhitPos]]                              ,listinput[[LifePosnVtPos]]                              ];htOpt[xt_,htStart_,AggState_,EmpState_,epDrawt_,LifePosn_] := Block[{},  xarg=xt;(*#  If[xt>xmax,xarg=xmax+(xarg-xmax)/2];*)  harg=htStart;(*#  If[harg>hsupermax,harg=hsupermax+(harg-hsupermax)/2];*)  PeriodOfOptimalRule = LifePosn;  If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved];  htOptInterpFunc[[PeriodOfOptimalRule]][xarg,harg,AggState,EmpState,epDrawt]];htOpt[listinput_] := htOpt[                               listinput[[xtVtPos]]                              ,listinput[[htStartVtPos]]                              ,listinput[[AggStateVtPos]]                              ,listinput[[EmpStateVtPos]]                              ,listinput[[epDrawtVtPos]]                              ,listinput[[LifePosnVtPos]]                              ];stOpt[xt_,htStart_,AggState_,EmpState_,epDrawt_,LifePosn_] := Block[{},  xarg=xt;(*#  If[xt>xmax,xarg=xmax+(xarg-xmax)/2];*)  harg=htStart;(*#  If[harg>hsupermax,harg=hsupermax+(harg-hsupermax)/2];*)  PeriodOfOptimalRule = LifePosn;  If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved];  stOptInterpFunc[[PeriodOfOptimalRule]][xarg,htStart,AggState,EmpState,epDrawt]];stOpt[listinput_] := stOpt[                               listinput[[xtVtPos]]                              ,listinput[[htStartVtPos]]                              ,listinput[[AggStateVtPos]]                              ,listinput[[EmpStateVtPos]]                              ,listinput[[epDrawtVtPos]]                              ,listinput[[LifePosnVtPos]]                              ];