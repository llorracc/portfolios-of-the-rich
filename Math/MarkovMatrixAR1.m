(* This procedure returns a Markov transition matrix that approximates an AR(1) process.*)MarkovMatrixAR1[mu_,sigma_,Cutoff_,lambda_,NumOfStates_] := Block[{},(*sigmasq,thetasq,theta,BoundaryPoints,IntervalMeanPoints,VarBounds,VarTransitionProbs},*)(*mu          - conditional mean (intercept) of the AR(1) processsigma       - standard deviation of shocks to the processlambda      - AR(1) coefficientNumOfStates - number of distinct possible values for level of the variable*)BoundaryPoints = IntervalMeanPoints = Table[0,{NumOfStates}]; AdjustmentFactor = -(1/2) sigma^2;   (* Factor which adjusts a lognormal to have mean 1 *)StandardizedBoundaryPoints =   Table[  LoopOverBoundaryPoints  ,{LoopOverBoundaryPoints,-Cutoff,Cutoff,2*Cutoff/NumOfStates}  ];  BoundaryPoints =   Table[    Quantile[      LogNormalDistribution[AdjustmentFactor,sigma]      ,CDF[NormalDistribution[0,1],StandardizedBoundaryPoints[[i]]]]  ,{i,Length[StandardizedBoundaryPoints]}];CDFofMissingBottom = CDF[LogNormalDistribution[AdjustmentFactor,sigma],BoundaryPoints[[ 1]]] //N;CDFofMissingTop    = (1-CDF[LogNormalDistribution[AdjustmentFactor,sigma],BoundaryPoints[[-1]]]) //N;CDFofMissing = CDFofMissingTop+CDFofMissingBottom;CDFAdjustFactor    = (1/(1-CDFofMissing));ProbOfMeanPoints =   Table[CDF[LogNormalDistribution[AdjustmentFactor,sigma],BoundaryPoints[[i]]]       -CDF[LogNormalDistribution[AdjustmentFactor,sigma],BoundaryPoints[[i-1]]]  ,{i,2,Length[BoundaryPoints]}]/(1-CDFofMissing);IntervalMeanPoints =  (Table[    NIntegrate[     x PDF[LogNormalDistribution[AdjustmentFactor,sigma],x]    ,{x,BoundaryPoints[[i-1]],BoundaryPoints[[i]]}]  ,{i,2,Length[BoundaryPoints]}]/(1-CDFofMissing))/ProbOfMeanPoints;sigmasq = sigma^2;thetasq = sigmasq/(1-(lambda^2));theta   = Sqrt[thetasq];LogVarStates = (Log[IntervalMeanPoints])/(.25);LogVarBounds = (Log[BoundaryPoints])    /(.25);VarStates = Exp[LogVarStates];VarBounds = Exp[LogVarBounds];Print["BoundaryPoints       = "<>ToString[BoundaryPoints]];Print["IntervalMeanPoints   = "<>ToString[IntervalMeanPoints]];Print["VarStates            = "<>ToString[VarStates]];Print["VarBounds            = "<>ToString[VarBounds]];VarTransitionProbs = Table[{},{i,NumOfStates},{j,NumOfStates}]; Do[  Do[   VarTransitionProbs[[i,j]] =     CDFAdjustFactor*     (Min[1/CDFAdjustFactor,Max[0,CDF[       NormalDistribution[AdjustmentFactor,sigma],       LogVarBounds[[j+1]]-lambda LogVarStates[[i]]]-CDFofMissingBottom]])    -CDFAdjustFactor*     (Min[1/CDFAdjustFactor,Max[0,CDF[       NormalDistribution[AdjustmentFactor,sigma],       LogVarBounds[[j  ]]-lambda LogVarStates[[i]]]-CDFofMissingBottom]]);(*   Print["VarTransitionProbs[["<>ToString[i]<>","<>ToString[j]<>"]] = ",VarTransitionProbs[[i,j]]];*),{j,NumOfStates}]; (* end Do for j*),{i,NumOfStates}]; (* end Do for i *)Print["Sum of transition probabilities"];Do[Print[Apply[Plus,VarTransitionProbs[[i]]]];VarTransitionProbs[[i]] = VarTransitionProbs[[i]]/CumulativeSums[VarTransitionProbs[[i]]][[-1]];,{i,NumOfStates}];Return[{VarStates,VarTransitionProbs}]]