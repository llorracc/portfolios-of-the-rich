If[VerboseOutput == True,Print["Running make_interpolating_FOC."]];(*If[BequestMotive && (LifePosn == LifeLength),    (* then *)      VtPrime[x_] := (((1-rho)VtRaw[x,PermIncGrid[[2]],2,1,LifePosn])^(rho/(1-rho)))VxtRaw[x,PermIncGrid[[2]],2,1,LifePosn];      VtPrimeWhereBeqMotiveKicksIn = VtPrime[BeqMotiveKicksIn];      AdditionalxGridPoints =         {(x /. FindRoot[VtPrime[x]==.9,{x,{1,2}}])        ,(x /. FindRoot[VtPrime[x]==.5,{x,{3,4}}])        ,(x /. FindRoot[VtPrime[x]==.2,{x,{BeqMotiveKicksIn-1,BeqMotiveKicksIn+1}}])        ,BeqMotiveKicksIn        };     xGrid = Union[xGridBaseline,AdditionalxGridPoints];     sGrid = Union[sGridBaseline,AdditionalxGridPoints-1];     MakeArgArrays[xFunctions];     MakeArgArrays[sFunctions];];    (* End If BequestMotive *)*)ctFOCInterpData[[LifePosn]] =     AddOutcome[ctFOCArgArray,Map[FindViaFOC[[LifePosn]],ctFOCArgArray]];ctFOCInterpFunc[[LifePosn]] =     Interpolation[ctFOCInterpData[[LifePosn]],InterpolationOrder->1];EarliestPeriodSolved = LifePosn;MakeInterpGivenFunctionName["stFOC",InterpOrder];(* Now find the set of x Gridpoints where liquidity constraints begin to bind *)(*If[etZeroProb == 0 && LifePosn<LifeLength,   ListOfxVals = {};  Do[	Do[		Do[			ListOfxVals=				Append[ListOfxVals,				(x /.					FindRoot[					  uprime[x] == 						beta[[LifePosn+1]] Phist[0,PermIncGrid[[LoopOverPermIncGrid]],LoopOverQStates,                    LoopOverEmpStates,LifePosn]				,{x,{xGrid[[1]],xGrid[[-1]]}}]				)]		,{LoopOverPermIncGrid,Length[PermIncGrid]}]	,{LoopOverQStates,Length[Q]}]  ,{LoopOverEmpStates,Length[EmpStateGrid]}];  xGrid = Union[xGrid,ListOfxVals];  x0Grid = Union[{0},xGrid];  MakeArgArrays[xFunctions];];*)(* Now find the set of x Gridpoints where liquidity constraints begin to bind *)If[etZeroProb == 0 && LifePosn<LifeLength,   ListOfxVals = {};  Do[	Do[		Do[			ListOfxVals=				Append[ListOfxVals,					(beta[[LifePosn+1]]*					 Phist[0					 ,PermIncGrid[[LoopOverPermIncGrid]]					 ,LoopOverQStates					 ,LoopOverEmpStates					 ,LifePosn])^(1/-rho)					];		,{LoopOverPermIncGrid,Length[PermIncGrid]}]	,{LoopOverQStates,Length[Q]}];  ,{LoopOverEmpStates,Length[EmpStateGrid]}];  ListOfxVals = Union[Round[ListOfxVals*100]/100] //N;  xGrid = Union[xGridBaseline,ListOfxVals];  x0Grid = Union[{0},xGrid];  MakeArgArrays[xFunctions];];EarliestPeriodSolved = LifePosn;VtArgArrayAugmented = AddOutcome[VtArgArray,Table[LifePosn,{Length[VtArgArray]}]];VxtScaled = (Map[Apply[VxtRaw, #] &,VtArgArrayAugmented])^(1/-rho);If[etZeroProb > 0,  (* then *)    ValOfVxtScaledAtxEq0 = 0;    MakeInterpWithZeroVals["Vxt",InterpOrder,VxtScaled,ValOfVxtScaledAtxEq0],  (* else *)    MakeInterpGivenFunctionNameAndResults["Vxt",VxtScaled,InterpOrder];];VtScaled = ((1-rho)*Map[Apply[VtRaw, #] &,VtArgArrayAugmented])^(1/(1-rho));If[etZeroProb > 0,  (* then *)    ValOfVtScaledAtxEq0 = 0;    MakeInterpWithZeroVals["Vt",InterpOrder,VtScaled,ValOfVtScaledAtxEq0],  (* else *)    MakeInterpGivenFunctionNameAndResults["Vt",VtScaled,InterpOrder]]ListOfZeros = Table[0,{Length[VtArgArray]}];VtPrimeResults = Map[Apply[VtPrime, #] &,VtArgArrayAugmented];VtPrimeInterpData[[LifePosn]] = AddOutcome[VtArgArray,VtPrimeResults];VtPrimeInterpFunc[[LifePosn]] = Interpolation[VtPrimeInterpData[[LifePosn]],InterpolationOrder->1];VtScaledFirstDerivs =   Transpose[    {VtPrimeResults     ,ListOfZeros     ,ListOfZeros     ,ListOfZeros    }];(*VtScaledFirstDerivs = Transpose[{(((1-rho)(Map[Apply[VtRaw,{#[[1]]+.0001,#[[2]],#[[3]],#[[4]],#[[5]]}] &,VtArgArrayAugmented]))^(1/(1-rho))-((1-rho)*Map[Apply[VtRaw,{#[[1]]-.0001,#[[2]],#[[3]],#[[4]],#[[5]]}] &,VtArgArrayAugmented])^(1/(1-rho)))/.0002,ListOfZeros,ListOfZeros,ListOfZeros}];VtFirstDerivs =  Transpose[    {VtScaled^rho*Map[Apply[VxtRaw,#] &,VtArgArrayAugmented]    ,ListOfZeros,ListOfZeros,ListOfZeros}];*)(*    VtScaledLevelAndFirstDerivs = Transpose[{VtScaled,VtScaledFirstDerivs}];If[etZeroProb > 0,  (* then *)    ValOfVtScaledAtsEq0 = {0,{1,0,0,0}};    MakeInterpWithZeroVals["Vt",InterpOrder,VtScaled,ValOfVtScaledAtsEq0],  (* else *)    MakeInterpGivenFunctionNameAndResults["Vt",VtScaledLevelAndFirstDerivs,InterpOrder]]*)(*If[BequestMotive,  AdditionalxGridPoints =     {(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==.8                          ,{x,{1,2}}])    ,(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==.5                          ,{x,{3,4}}])    ,(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==.2                          ,{x,{BeqMotiveKicksIn-1,BeqMotiveKicksIn+1}}])    ,(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==VtPrimeWhereBeqMotiveKicksIn,{x,{BeqMotiveKicksIn-1,BeqMotiveKicksIn+1}}])            };    xGrid = Union[xGridBaseline,AdditionalxGridPoints];    MakeArgArrays[xFunctions];];*)(*    AdditionalxGridPoints =       {(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==.99                        ,{x,{1,2}}])      ,(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==(VtPrimeAtBeqKinkPoint+1)/2,{x,{1,2}}])      ,(x /. FindRoot[VtPrimeInterpFunc[[LifePosn]][x,PermIncGrid[[2]],2,1]==VtPrimeAtBeqKinkPoint      ,{x,{BeqMotiveKicksIn-1,BeqMotiveKicksIn+1}}])      };*)