(* % Defines all of the baseline parameter values and    % converts them to per period rates where necessary *)Print["Reading in the baseline parameter values."];SolutionMethod = FOC;(* Can solve either via Value function or via FOCs or Both; FOCs is much better *)BequestMotive = True;(* Flag for whether they have a bequest motive *)rho = 6.;            (* Coefficient of relative risk aversion                     *)alpha = rho/2;       (* Parameter that governs the degree to which bequests are a luxury good *)lambda = 10;         (* Parameter that determines level of permanent income where consumers start getting positive marginal utility from bequests *)tau = .05;           (* Proportion of working hours that must be devoted to the entrepreneurial project *)If[BequestMotive == True,   BeqMotiveKicksIn =   (* Level of last-period x where bequest motive becomes operative *)    (xt /. FindRoot[.5(-1 + (1 + 4 lambda + 4 xt)^.5)== xt,{xt,{2,3}}])];YearsOfLife    = 80; (* For finite-horizon version, life starts at age 20 and ends at 100 *)PeriodsPerYear = 1;  (* 1 for annual, 4 for quarterly, 12 for monthly (AS IF!)   *)LifeLength  = YearsOfLife*PeriodsPerYear;FirstPeriod = 1;etSig  = .10;        (* Standard deviation of the lognormally distributed component of the transitory earnings shock *)epSig  = .0;         (* Standard deviation of the lognormally distributed permanent income shock *)Cutoff = 3;          (* How many standard deviations above and below the mean to truncate the income shock distributions *)etZeroProb = 0.01;   (* The probability of a zero-income event *)NumOfetVals = 3;     (* Number of points in the discrete approximation to the transitory shock *)NumOfepVals = 1;     (* Number of points in the discrete approximation to the permanent shock *)RSig = .157;         (* The standard deviation of the rate of return on the risky asset *)RCutoff = 3;         (* How many standard deviations off to cut off the distribution of R *)NumOfRVals = 3;      (* Number of points in the discrete approximation to the rate-of-return shock *)EquityPremium=.04;   (* How much higher is the rate of return on equities than the certain rate? *)NumOfRSteps = 6;     (* How many possible portfolio shares to consider? *)KSig = RSig;         (* Standard deviation of rate of return on entrepreneurial investment if no failure *)KCutoff = 3;         (* How many standard deviations off to cut off the distribution of K *)NumOfKVals  = 3;     (* Number of points in the discrete approximation to the rate-of-return shock *)KPremium    =.10;    (* How much higher is the rate of return on entrepreneurship than on equities? *)NumOfKSteps = 6;     (* How many possible portfolio shares to consider? *)KFailProb   =.05;    (* Annual risk that the business will collapse *)KShareMin   = .0;    (* Minimum portion of portfolio that must be devoted to the business *)KReturnMin  = (1/(Rcertain+EquityPremium+KPremium));ProbOfNewIdea =.05;  (* Indicates the probability that the consumer will have an entrepreneurial idea *)NumOfQStates = 2;    (* Q indicates the quality of the entrepreneurial idea *)NumOfEmpStates = 1;  (* Machinery for implementing realistic unemployment spells, if desired *)EmpStateTransitionMatrix = Table[{{1}},{NumOfQStates}];CumEmpStateTransitionMatrix = EmpStateTransitionMatrix;NumOfPermIncVals= 5;      (* Number of discrete possible values for the level of permanent income *)LogPermIncShockSig = .1;  (* Standard deviation of annual shocks to permanent income *)LogPermIncAR1Coeff = .95; (* Serial correlation coefficient in AR(1) for permanent income *)PermIncCutoff     = 3;    (* Truncate permanent income shocks at 3 standard deviations *)NumOfPermIncShocks= 2;{PermIncShocks,PermIncShocksProb} =   DiscreteApproxToMeanOneLogNormalWithCutoff[PermIncCutoff,LogPermIncShockSig,NumOfPermIncShocks];CumPermIncShocksTransitionMatrix =   Table[CumulativeSums[PermIncShocksProb],{LoopOverPermIncShocks,Length[PermIncShocks]}];PermIncGrid = DiscreteApproxToMeanOneLogNormalWithCutoff[PermIncCutoff,LogPermIncShockSig*10,NumOfPermIncVals][[1]];SolveForRiskyShare = True;SolveForKShare = True;InterpOrder = 1;                        (* % Order of interpolation in the interpolating functions; 1 is linear *)(* % Growth rate is potentially different for each agg state *)Gannual = Table[{},{NumOfQStates}]; Rcertain = 1.02;(* Draw the set of possible values for the return on stocks*){Rannual,Rprob} = DiscreteApproxToMeanOneLogNormalWithCutoff[RCutoff,RSig,NumOfRVals];Rannual = (Rcertain+EquityPremium) Rannual;(* Allow for a 1 percent probability that the market will lose 90 percent of its value *)Rannual = (Rannual-.1*.01)/.99; Rannual = Prepend[Rannual,.1];Rprob = .99 Rprob;Rprob = Prepend[Rprob,.01];NumOfRVals++;(* Draw the set of possible values for the return on entreprenurial ventures*){Kannual,Kprob} = DiscreteApproxToMeanOneLogNormalWithCutoff[KCutoff,KSig,NumOfKVals];Kannual = (Rcertain+EquityPremium+KPremium) Kannual;Kannual = (Kannual/(1-KFailProb))-0.1*KFailProb/(1-KFailProb); Kannual = Prepend[Kannual,0.1];Kprob = (1-KFailProb) Kprob;Kprob = Prepend[Kprob,KFailProb];NumOfKVals++;(* QState indicates the Quality of the current project. 1=no entrepreneurial project.2=highest quality, project yields expected returns = 1+EquityPremium+KPremium3=medium quality,  project yields geometric mean between EquityPremium and KPremium4=low quality,     project yields 1+EquityPremium but is higher risk*)Q     =  {0         ,1};(*         ,(((1+EquityPremium)*(1+EquityPremium+KPremium))^.5)/(1+EquityPremium+KPremium)         ,(1+EquityPremium)/(1+EquityPremium+KPremium)         };   *)(* % The QStateTransitionMatrix governs the probabilities of moving to    % each Q state tomorrow given a current aggregate state today.     Currently set so that there is zero probability of transitionQStateTransitionMatrix    = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};CumQStateTransitionMatrix = {{1,1,1,1},{0,1,1,1},{0,0,1,1},{1,1,1,1}};*)QStateTransitionMatrix    = {{1,0},{0,1}};CumQStateTransitionMatrix = {{1,1},{0,1}};<<life_cycle.m;(* Convert annual flow variables to per-period rates *)G      = Gannual^(1/PeriodsPerYear);            (* Growth rates by aggregate state                        *)R      = Rannual^(1/PeriodsPerYear);            (* Interest rates by aggregate state                      *) K      = Kannual^(1/PeriodsPerYear);            (* Interest rates by aggregate state                      *) beta   = betaannual^(1/PeriodsPerYear);         (* Time preference discount factor                        *)(* % Add epsilon to consumption and housing in utility function    % so that u(0,0) is not -Infinity *)(* epsilon=.1;  *)epsilon=.0001;(* Set up the limits and the grid density for the state variables *)(* % cash-on-hand limits *)(* make xmax  =  5. * PeriodsPerYear if doing annual *)xmin  =  0.;xmax  =  Round[G[[LifeLength]]*10] * PeriodsPerYear;NumOfxSteps = 8;(* % savings limits *)smin  = 0.;smax  = xmax;NumOfsSteps = 10;RStateTransitionMatrix = Rprob;CumRStateTransitionMatrix =   Table[    {CumulativeSums[Rprob]}    ,{Length[Rprob]}  ];KStateTransitionMatrix = Kprob;CumKStateTransitionMatrix =   Table[    {CumulativeSums[Kprob]}    ,{Length[Kprob]}  ];LowMem = False;  (* Determines whether the low-memory version of the programs is run *)VerboseSetup = False; (* Determines how much printing happens *)