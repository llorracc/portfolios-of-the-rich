(*% This program defines the "pure" functions which return the value % of pursuing each of the possible housing options available at time LifePosn for % a given state. % FindBest requires several ambient variables to be defined.*)If[VerboseOutput == True,Print["Running FindKSharet.m"]];FindKShareSt[[LifePosn]] =Block[{ st         = #[[stInPosFOC]],PermInc    = #[[PermIncInPosFOC]],QState     = #[[QStateInPosFOC]],EmpState   = #[[EmpStateInPosFOC]]},  If[SolveForKShare == False,    (* then *) KSharet = 0,    (* else *)        If[st > smin,                  (*   If they have positive liquid assets            *)           (* then *)                 (*     then choose optimal level of expenditures et *)                 KShareResults=	        (* %   to maximize utility u[] by minimizing        *)	                 FindRoot[                            FOCwrtKSharet[st                                   ,PermInc                                   ,QState                                   ,EmpState                                   ,KShare                                   ,RiskyShareKt[st,PermInc,QState,EmpState,KShare,LifePosn]                                   ,LifePosn]==0                     ,{KShare,{KShareMin,1}},MaxIterations->100];              If[Length[KShareResults]>2,Print["KShareResults of improper form; probably FindRoot failed"];Interrupt[]];              KSharet = Round[(KShare /. KShareResults)*1000]/1000;              If[KSharet>1, (* then *) KSharet=1];              If[KSharet<0, (* then *) KSharet=0];            ,(* else *)              KShare = KSharet = 0;       ];  (* End If st > smin *)  ];       (* End If SolveForKShare == False *)KSharet //N] &;