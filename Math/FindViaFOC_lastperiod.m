(*% This program defines the "pure" functions which return the value % of pursuing each of the possible housing options available at time LifePosn for % a given state. % FindBest requires several ambient variables to be defined.*)If[VerboseOutput == True,Print["Running FindViaFOC_lastperiod.m"]];FindViaFOC[[LifePosn]] =Block[{ xt           = #[[xtInPos]],PermInc      = #[[PermIncInPos]],QState       = #[[QStateInPos]],EmpState     = #[[EmpStateInPos]]},  If[xt < xmin,    (* then punish them for violating the liquidity constraint *)      RiskySharet=ct=zt=st=et=0;      vt= AvoidLikePlague,    (* else xt >= xmin *)      If[xt == xmin,        ct = xt,      (* else find the optimum *)        If[rho/alpha == 2,          (* then *)            ct = .5(-1 + (1 + 4 lambda + 4 xt)^.5);            If[ct > xt, (* then *) ct = xt];    (* can't spend more than current resources *)            stVxt = xt-ct,          (* else *)            FOCResults =                 FindRoot[                    c == (xt-c+lambda)^(alpha/rho)                ,{c,{xmin+epsilon, xt}}];            If[Length[FOCResults]>2,Print["FOCResults of improper form; probably FindRoot failed."];Interrupt[]];            ct = (c /. FOCResults);            If[Not[NumberQ[ct]], (* then *) Print["FindViaFOC failed."];Print[##];Interrupt[]];           ]; (* End If rho/alpha == 2 *)          st = xt-ct;If[st < 0,st=0;ct=xt;(*#Print["Error in ChoiceBasic: st < 0"];Print[##];Interrupt[]#*)];       ]; (* End IF xt == xmin *)  ]; (* End If[xt < xmin] *)ct ] &;