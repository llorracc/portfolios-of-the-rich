Omega[KShare_] :=   If[KShare >= KShareMin,    (* then *)     If[KShare <= 1,      (* then *)        KReturnMin         -2(KReturnMin-1)(KShare-KShareMin)/(              1-KShareMin)+((KReturnMin-1)((KShare-KShareMin)/(1-KShareMin))^2),            (* else *) 1],    (* else *) 0    ];    Omega[KShare_] :=     If[KShare <= 1,      (* then *)        KReturnMin         -2(KReturnMin-1)(KShare-KShareMin)/(              1-KShareMin)+((KReturnMin-1)((KShare-KShareMin)/(1-KShareMin))^2),      (* else *) 1];OmegaPrime[KShare_] :=  If[KShare <= 1,   (* then *)      -2(KReturnMin-1)/(1-KShareMin) +       2((KReturnMin-1)/(1-KShareMin)) (KShare-KShareMin)/(1-KShareMin),   (* else *) 0];u[c_]      := (c^(1-rho))/(1-rho);uprime[c_] := c^-rho;ClearAll[B];If[BequestMotive == True,  (* then *)    B[s_]      := ((s+lambda)^(1-alpha))/(1-alpha);    Bprime[s_] := (s+lambda)^-alpha,  (* else *)    B[s_]      := 0;    Bprime[s_] := 0;];  Phit[s_, PermInc_, QState_, EmpState_, LifePosn_] :=   ((PhitInterpFunc[[        Max[EarliestEtVtp1Solved, LifePosn]]][s,     PermInc, QState, EmpState])^(1-rho))/(1-rho);Phist[s_, PermInc_, QState_, EmpState_, LifePosn_] :=   (PhistInterpFunc[[        Max[Min[EarliestPeriodSolved, EarliestEtVtp1Solved], LifePosn]]][s,     PermInc, QState, EmpState])^(-rho)VtRaw[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},If[LifePosn>LifeLength,  (* then *)    0,  (* else *)    If[LifePosn == LifeLength,      (* then *)      If[BequestMotive == True,        (* then *)          If[rho/alpha == 2,            (* then *)              ctVt = .5(-1 + (1 + 4 lambda + 4 xt)^.5);              If[ctVt > xt, (* then *) ctVt = xt];    (* can't spend more than current resources *)              stVt = xt-ctVt,            (* else rho/alpha != 2 *)              ctVt = ctFOC[xt,PermInc,QState,EmpState,LifePosn];              stVt = xt-ctVt;            ]; (* End if alpha/rho == 2 *)           u[ctVt]+B[stVt],        (* else BequestMotive != True *)           u[xt]        ],    (* End if BequestMotive == True *)      (* else LifePosn < LifeLength *)      ctVt = ctFOC[xt,PermInc,QState,EmpState,LifePosn];xtVt=xt;stVt=Chop[xtVt-ctVt];PermIncVt=PermInc;QStateVt=QState;LifePosnVt=LifePosn;      u[ctVt] + beta[[LifePosn+1]] Phit[stVt,PermInc,QState,EmpState,LifePosn]    ] (* End If LifePosn==LifeLength *)  ]   (* End If LifePosn>LifeLength  *)]Vt[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},If[LifePosn>LifeLength,  (* then *)    0,  (* else *)    If[(xt < xmin && etZeroProb==0) || (xt <= xmin && etZeroProb >0),      (* then *) GreatBadness,      (* else *)      If[LifePosn == LifeLength,        (* then *)          VtRaw[xt,PermInc,QState,EmpState,LifePosn],        (* else LifePosn < LifeLength *)          ((VtInterpFunc[[Max[EarliestPeriodSolved,LifePosn]]][xt,PermInc,QState,EmpState])^(1-rho))/(1-rho)      ] (* End If LifePosn == LifeLength *)    ]   (* End If xt<xmin *)   ]    (* End If LifePosn>LifeLength *)]ClearAll[ctFOC];ctFOC[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},If[LifePosn>LifeLength,  (* then *)    0,  (* else *)  If[(xt < xmin && etZeroProb==0) || (xt <= xmin && etZeroProb >0),xmin,    (* else *)    If[LifePosn == LifeLength,      (* then *)        If[rho/alpha == 2,          (* then *)            ctFOCVal = .5(-1 + (1 + 4 lambda + 4 xt)^.5);            If[ctFOCVal > xt, (* then *) ctFOCVal = xt];    (* can't spend more than current resources *)            stFOCVal = xt-ctFOCVal,          (* else *)            ctFOCVal = ctFOCInterpFunc[[Max[EarliestPeriodSolved,LifePosn]]][xt,PermInc,QState,EmpState];            stFOCVal = xt-ctFOCVal;          ]; (* End if alpha/rho == 2 *)        ctFOCVal,      (* else LifePosn < LifeLength *)        ctFOCInterpFunc[[Max[EarliestPeriodSolved,LifePosn]]][xt,PermInc,QState,EmpState]    ] (* End If LifePosn == LifeLength *)  ]   (* End If xt<xmin *) ]    (* End If LifePosn>LifeLength *)]ClearAll[stFOCRaw];stFOCRaw[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Chop[xt-ctFOC[xt,PermInc,QState,EmpState,LifePosn]];ClearAll[Vxt];Vxt[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},xtVxt = xt;If[(xt < xmin && etZeroProb ==0) || (xt <= xmin && etZeroProb >0),               (* If they have arrived in this period with assets less than the minimum allowed amount *)  (* then *) VxtOut = AvoidLikePlague,  (* Extremely high marginal utility should make them avoid forbidden x's *)  (* else *)                   (* else proceed normally                                    *)    If[LifePosn < EarliestPeriodSolved,PeriodOfOptimalRule = EarliestPeriodSolved,PeriodOfOptimalRule = LifePosn];     If[LifePosn>=LifeLength,                           (* If it's the last period of life or later                               *)      (* then *)         If[LifePosn==LifeLength,          (* then *)             If[rho/alpha == 2,  (* if rho/alpha=2 there is an analytical solution *)              (* then *)                ctVxt = .5(-1 + (1 + 4 lambda + 4 xt)^.5);                If[ctVxt > xt, (* then *) ctVxt = xt];    (* can't spend more than current resources *)                stVxt = xt-ctVxt,              (* else rho/alpha != 2 *)                ctVxt = ctFOC[xt,PermInc,QState,EmpState,LifePosn];                stVxt = xt-ctVxt;              ]; (* End if alpha/rho == 2 *)              If[stVxt>0,                (* then *)                 VxtOut = Bprime[stVxt], (* From the envelope theorem, Vxt = B'(s); see notes *)                (* else *)                 VxtOut = uprime[ctVxt]                ], (* End If stVxt>0 *)          (* else it's later than the last period of life *)            VxtOut = 0          ], (* End If[LifePosn==LifeLength] *)      (* else LifePosn < LifeLength *)        VxtOut=Max[0,(VxtInterpFunc[[PeriodOfOptimalRule]][xtVxt,PermInc,QState,EmpState])^-rho];    ];  (* End If LifePosn>=LifeLength  *)  ];    (* End If[xt < xmin]            *)VxtOut] (* End of Block *)ClearAll[VxtRaw];VxtRaw[xt_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},If[LifePosn>LifeLength,  (* then *) VxtOut = 0,  (* Else *)  If[xt<xmin,Print["VxtRaw called with xt<xmin."];Interrupt[];AvoidLikePlage,    (* else *)    If[xt>xmax,       (* then use the interpolatingfunction, which is actually more accurate outside the grid *)        Vxt[xt,PermInc,QState,EmpState,LifePosn],      (* else proceed normally *)        ctVxt = ctFOC[xt,PermInc,QState,EmpState,LifePosn];        stVxt = Chop[xt-ctVxt];        If[LifePosn==LifeLength,          (* then *)             If[rho/alpha == 2,  (* if rho/alpha=2 there is an analytical solution *)              (* then *)                ctVxt = .5(-1 + (1 + 4 lambda + 4 xt)^.5);                If[ctVxt > xt, (* then *) ctVxt = xt];    (* can't spend more than current resources *)                stVxt = xt-ctVxt;              ]; (* End if alpha/rho == 2 *)              If[stVxt>0,                (* then *)                 VxtOut = Bprime[stVxt], (* From the envelope theorem, Vxt = B'(s); see notes *)                (* else *)                 VxtOut = uprime[ctVxt]],          (* else LifePosn < LifeLength *)          If[ctVxt < 0,            (* then *)              VxtOut = AvoidLikePlague,            (* else *)              If[stVxt > 0,                 (* then the Envelope theorem applies *)                   VxtOut = beta[[LifePosn+1]] Phist[stVxt,PermInc,QState,EmpState,LifePosn],                (* else they are liquidity constrained so marginal value is marginal utility of consumption *)                  VxtOut = uprime[ctVxt]                ] (* End If stVxt > 0 *)          ] (* End If ctVxt <= 0 *)        ]   (* End IF LifePosn==LifeLength *)      ]     (* End If xt>xmax *)    ](* End If xt<xmin *)  ]; (* End If LifePosn>LifeLength *)  If[VxtOut<0,    (* then *)       Print["Warning: VxtRaw[",xt,",",PermInc,",",QState,",",EmpState,",",LifePosn,"]=",VxtOut,"<0."];  ]; (* End If VxtOut < 0 *)Return[VxtOut]];ClearAll[MakeEtp1Raw];MakeEtp1Raw[st_,PermInc_,QState_,EmpState_,KSharet_,RiskySharet_,LifePosn_] := Block[{}, sttmp=st;PermInctmp=PermInc;QStatetmp=QState;EmpStatetmp=EmpState;KSharettmp=KSharet;RiskySharettmp=RiskySharet; If[KSharet>1 || KSharet<0 || RiskySharet>1 || RiskySharet<0,   (* then they've violated the portfolio constraints so punish them *)     {AvoidLikePlague,AvoidLikePlague,AvoidLikePlague,GreatBadness},   (* else they've chosen valid portfolio shares so calculate values *)  (1-ProbOfDeath[[LifePosn+1]])*   Sum[             (* over possible entrepreneurial rates of return       *)    Sum[            (* over possible stock rates of return                 *)     Sum[           (* over possible future employment states              *)      Sum[          (* over possible future aggregate states               *)       Sum[         (* over possible future values of the permanent shock  *)        Sum[        (* over possible future values of the transitory shock *)          ptp1 = Exp[LogPermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]];          Rtp1 = (R[[LoopOverRVals]]*RiskySharet*(1-KSharet)                 +If[QState>1,K[[LoopOverKVals]]*KSharet*Omega[KSharet],0]                 +Rcertain*((1-KSharet)(1-RiskySharet)));          xtp1 = Rtp1*st                 +ptp1*G[[LifePosn+1]]*etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]*(1-tau*Q[[LoopOverQStates]]);(*        If[xtp1<0,Print["Error in MakeEtp1: xtp1<0.  xtp1=",xtp1]; Interrupt[];];       *)(*        xtp1List = Append[xtp1List,xtp1]; *)(*         Rtp1List = Append[Rtp1List,Rtp1];*)        Results = Join[            {st*(K[[LoopOverKVals]] Q[[LoopOverQStates]](Omega[KSharet]+KSharet*OmegaPrime[KSharet])-(Rcertain(1-RiskySharet)+R[[LoopOverRVals]]RiskySharet))            ,st*(R[[LoopOverRVals]]-Rcertain)(1-KSharet)            ,Rtp1}*            Vxt[xtp1,ptp1,LoopOverQStates,LoopOverEmpStates,LifePosn+1]          ,{ Vt[xtp1,ptp1,LoopOverQStates,LoopOverEmpStates,LifePosn+1]}];(*          Print[{ptp1,Rtp1,xtp1}]; *)(*{0,0,0,If[Rtp1==0,"Rtp1Zero","Rtp1>0"]}*)(*            "{K="<>ToString[LoopOverKVals]<>",Q="<>ToString[LoopOverQStates]<>",Emp="<>ToString[LoopOverEmpStates]<>",R="<>ToString[LoopOverRVals]<>",Perm="<>ToString[LoopOverPermIncShocks]<>",Rtp1="<>ToString[Rtp1]<>"}"*)(*          {0,0  ,If[Rtp1>0,"Rtp1 Vxt["<>ToString[xtp1]<>","<>ToString[ptp1]<>","<>ToString[Rtp1]<>"]="<>ToString[Rtp1]<>"*"<>ToString[FortranForm[Results[[3]]]],0],0}*)(*          {0,0,0,If[Rtp1>0,"Rtp1 Vt["<>ToString[xtp1]<>","<>ToString[ptp1]<>","<>ToString[Rtp1]<>"]="<>ToString[Rtp1]<>"*"<>ToString[FortranForm[Results[[4]]]],0]} *)(*InputsList = Append[InputsList,{{ptp1,Rtp1,xtp1,LoopOverQStates,QStateProbtp1[QState,KSharet,LoopOverKVals,LoopOverQStates]}}];ResultsList = Append[ResultsList,Results]*);           Results         *etProb[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]        ,{LoopOveretVals,Length[etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates]]]}] (* End loop over etVals     *)         *PermIncShocksProb[[LoopOverPermIncShocks]]       ,{LoopOverPermIncShocks,Length[PermIncShocks]}]                           (* End loop over PermIncGrid     *)        *Rprob[[LoopOverRVals]]      ,{LoopOverRVals,NumOfRVals}]                                               (* End loop over RVals *)       *EmpStateProb[QState,EmpState,LoopOverEmpStates]     ,{LoopOverEmpStates,NumOfEmpStates}]                                        (* End loop over EmpStates  *)      *QStateProbtp1[QState,KSharet,LoopOverKVals,LoopOverQStates]    ,{LoopOverQStates,NumOfQStates}]                                             (* End loop over QStates  *)     *Kprob[[LoopOverKVals]]   ,{LoopOverKVals,Length[K]}] +ProbOfDeath[[LifePosn+1]]*{0,0,(st+lambda)^(-alpha),((st+lambda)^(1-alpha))/(1-alpha)} ] (* End If KSharet>1 *)] PhiKSst[st_,PermInc_,QState_,EmpState_,KShare_,RiskyShare_,LifePosn_] :=   (PhiKSstInterpFunc[[      Max[Min[EarliestPeriodSolved, EarliestEtVtp1Solved], LifePosn]]][st,   PermInc, QState, EmpState, KShare, RiskyShare])^-rho;PhiKSt[st_,PermInc_,QState_,EmpState_,KShare_,RiskyShare_,LifePosn_] := Block[{},  If[KShare<0 || KShare>1 || RiskyShare<0 || RiskyShare>1 || (KShare>0 && KShare<KShareMin),    GreatBadness,  ((PhiKStInterpFunc[[      Max[Min[EarliestPeriodSolved, EarliestEtVtp1Solved], LifePosn]]][st,   PermInc, QState, EmpState, KShare, RiskyShare])^(1-rho))/(1-rho)]  ];PhitRaw[st_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},  KSharetOpt      = KSharet[     st,PermInc,QState,EmpState,LifePosn];  RiskyShareKtOpt = RiskyShareKt[st,PermInc,QState,EmpState,KSharetOpt,LifePosn];  PhiKSt[st,PermInc,QState,EmpState,KSharetOpt,RiskyShareKtOpt,LifePosn]];PhistRaw[st_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},  KSharetOpt      = KSharet[     st,PermInc,QState,EmpState,LifePosn];  RiskyShareKtOpt = RiskyShareKt[st,PermInc,QState,EmpState,KSharetOpt,LifePosn];  PhiKSst[st,PermInc,QState,EmpState,KSharetOpt,RiskyShareKtOpt,LifePosn]];FOCwrtKSharet[s_, PermInc_, QState_, EmpState_, KShare_,RiskyShare_,LifePosn_] :=   FOCwrtKSharetInterpFunc[[        Max[Min[EarliestPeriodSolved, EarliestEtVtp1Solved], LifePosn]                         ]][s, PermInc,QState, EmpState,KShare,RiskyShare];ClearAll[FOCwrtKSharetRaw];FOCwrtKSharetRaw[st_,PermInc_,QState_,EmpState_,KSharet_,RiskySharet_,LifePosn_] := Block[{},  (1-ProbOfDeath[[LifePosn+1]])*st*   Sum[             (* over possible entrepreneurial rates of return       *)    Sum[            (* over possible stock rates of return                 *)     Sum[           (* over possible future employment states              *)      Sum[          (* over possible future aggregate states               *)       Sum[         (* over possible future values of the permanent shock  *)        Sum[        (* over possible future values of the transitory shock *)           (Rcertain          -Q[[LoopOverQStates]] K[[LoopOverKVals]](Omega[KSharet]+KSharet*OmegaPrime[KSharet]))*           Vxt[           (R[[LoopOverRVals]]*RiskySharet            +Q[[LoopOverQStates]]*K[[LoopOverKVals]]*KSharet            +Rcertain*(1-KSharet-RiskySharet))*st           +Exp[LogPermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]*              G[[LifePosn+1]]*etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]           ,Exp[LogPermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]           ,LoopOverQStates           ,LoopOverEmpStates           ,LifePosn+1           ]          *etProb[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]        ,{LoopOveretVals,Length[etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates]]]}] (* End loop over etVals     *)         *PermIncShocksProb[[LoopOverPermIncShocks]]       ,{LoopOverPermIncShocks,Length[PermIncShocks]}]                           (* End loop over PermIncGrid     *)        *Rprob[[LoopOverRVals]]      ,{LoopOverRVals,NumOfRVals}]                                               (* End loop over RVals *)       *EmpStateProb[QState,EmpState,LoopOverEmpStates]     ,{LoopOverEmpStates,NumOfEmpStates}]                                        (* End loop over EmpStates  *)      *QStateProbtp1[QState,KSharet,LoopOverKVals,LoopOverQStates]    ,{LoopOverQStates,NumOfQStates}]                                             (* End loop over QStates  *)     *Kprob[[LoopOverKVals]]   ,{LoopOverKVals,Length[Kprob]}] +ProbOfDeath[[LifePosn+1]]*(st+lambda)^-alpha]FOCwrtRiskySharet[s_, PermInc_, QState_, EmpState_, KShare_,RiskyShare_, LifePosn_] :=   FOCwrtRiskySharetInterpFunc[[        Max[Min[EarliestPeriodSolved, EarliestEtVtp1Solved], LifePosn]                              ]][s, PermInc,QState, EmpState,KShare,RiskyShare](*ClearAll[FOCwrtRiskySharetRaw];FOCwrtRiskySharetRaw[st_,PermInc_,QState_,EmpState_,RiskySharet_,KSharet_,LifePosn_] := Block[{},  OptimalKShare = KSharetGivenSSharet[st,PermInc,QState,EmpState,RiskySharet,LifePosn];  (1-ProbOfDeath[[LifePosn+1]])*st*   Sum[             (* over possible entrepreneurial rates of return       *)    Sum[            (* over possible stock rates of return                 *)     Sum[           (* over possible future employment states              *)      Sum[          (* over possible future aggregate states               *)       Sum[         (* over possible future values of the permanent shock  *)        Sum[        (* over possible future values of the transitory shock *)           (Rcertain          -R[[LoopOverRVals]])*st*           Vxt[           (R[[LoopOverRVals]]*RiskySharet            +Q[[LoopOverQStates]]*K[[LoopOverKVals]]*KSharet            +Rcertain*(1-KSharet-RiskySharet))*st           +Exp[LogPermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]*G[[LifePosn+1]]*etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]           ,Exp[LogPermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]           ,LoopOverQStates           ,LoopOverEmpStates           ,LifePosn+1           ]          *etProb[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]        ,{LoopOveretVals,Length[etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates]]]}] (* End loop over etVals     *)         *PermIncShocksProb[[LoopOverPermIncShocks]]       ,{LoopOverPermIncShocks,Length[PermIncShocks]}]                           (* End loop over PermIncGrid     *)        *Rprob[[LoopOverRVals]]      ,{LoopOverRVals,NumOfRVals}]                                               (* End loop over RVals *)       *EmpStateProb[QState,EmpState,LoopOverEmpStates]     ,{LoopOverEmpStates,NumOfEmpStates}]                                        (* End loop over EmpStates  *)      *QStateProbtp1[QState,KSharet,LoopOverKVals,LoopOverQStates]    ,{LoopOverQStates,NumOfQStates}]                                             (* End loop over QStates  *)     *Kprob[[LoopOverKVals]]   ,{LoopOverKVals,Length[Kprob]}] +ProbOfDeath[[LifePosn+1]]*(st+lambda)^-alpha]*)(*ClearAll[PhitRaw];PhitRaw[st_,PermInc_,QState_,EmpState_,KSharet_,RiskySharet_,LifePosn_] := Block[{},  (1-ProbOfDeath[[LifePosn+1]])*   Sum[             (* over possible entrepreneurial rates of return       *)    Sum[            (* over possible stock rates of return                 *)     Sum[           (* over possible future employment states              *)      Sum[          (* over possible future aggregate states               *)       Sum[         (* over possible future values of the permanent shock  *)        Sum[        (* over possible future values of the transitory shock *)              Vt[             (R[[LoopOverRVals]]*RiskySharet              +Q[[LoopOverQStates]]*K[[LoopOverKVals]]*KSharet              +Rcertain*(1-KSharet-RiskySharet))*st             +Exp[PermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]*G[[LifePosn+1,QState]]*etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]             ,Exp[PermIncAR1Coeff*Log[PermInc]]*PermIncShocks[[LoopOverPermIncShocks]]             ,LoopOverQStates             ,LoopOverEmpStates             ,LifePosn+1             ]          *etProb[[LifePosn+1,LoopOverQStates,LoopOverEmpStates,LoopOveretVals]]        ,{LoopOveretVals,Length[etVals[[LifePosn+1,LoopOverQStates,LoopOverEmpStates]]]}] (* End loop over etVals     *)         *PermIncShocksProb[[LoopOverPermIncShocks]]       ,{LoopOverPermIncShocks,Length[PermIncShocks]}]                             (* End loop over PermIncGrid     *)        *Rprob[[LoopOverRVals]]      ,{LoopOverRVals,NumOfRVals}]                                           (* End loop over RVals *)       *EmpStateProb[QState,EmpState,LoopOverEmpStates]     ,{LoopOverEmpStates,NumOfEmpStates}]                                        (* End loop over EmpStates  *)      *QStateProbtp1[QState,KSharet,LoopOverKVals,LoopOverQStates]    ,{LoopOverQStates,NumOfQStates}]                                             (* End loop over QStates  *)     *Kprob[[LoopOverKVals]]   ,{LoopOverKVals,Length[Kprob]}] +ProbOfDeath[[LifePosn+1]]*(st+lambda)^-alpha]*)CertEquivRaw[st_,PermInc_,QState_,EmpState_,LifePosn_] := Block[{},If[st <= 0,  (* then *) 0,  (* Else *)    (beta[[LifePosn+1]] PhistRaw[st,PermInc,QState,EmpState,LifePosn])^(-1/rho)] (* End IF st<= 0 *)];Remove[PhiKStPrime];PhiKStPrime[s_,PermInc_,QState_,EmpState_,KShare_,RiskyShare_,LifePosn_] :=Block[{},  sGridPosn = Position[sGrid,s];  If[sGridPosn == {}, (* then *)  sVal = s; Print["PhiKStPrime called with value of s not in sGrid: s=",sVal]; Interrupt[];Return[]];  sGridPosn = sGridPosn[[1,1]];  If[sGridPosn > 1 && sGridPosn < Length[sGrid],    (* then it's an intermediate point *)    PhiKStPrimeVal =       (      (PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn+1]],PermInc,QState,EmpState,KShare,RiskyShare]      -PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState,KShare,RiskyShare])      *((sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]])/(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]]))+      (PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState,KShare,RiskyShare]      -PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn-1]],PermInc,QState,EmpState,KShare,RiskyShare])      *((sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]])/(sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]]))      )      /(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn-1]]),    (* else *)      If[sGridPosn == 1,        (* then *)          PhiKStPrimeVal =            (PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn+1]],PermInc,QState,EmpState,KShare,RiskyShare]           -PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState,KShare,RiskyShare])           /(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]]),        (* else it's the last value in sGridPosn *)          PhiKStPrimeVal =            (PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn]],PermInc,QState,EmpState,KShare,RiskyShare]           -PhiKStInterpFunc[[LifePosn]][sGrid[[sGridPosn-1]],PermInc,QState,EmpState,KShare,RiskyShare])           /(sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]])        ] (* End If sGridPosn     *)    ];    (* End If sGridPosn > 1 *)Return[PhiKStPrimeVal]]Remove[PhitPrime];PhitPrime[s_,PermInc_,QState_,EmpState_,LifePosn_] :=Block[{},  sGridPosn = Position[sGrid,s];  If[sGridPosn == {}, (* then *)  sVal = s; Print["PhitPrime called with value of s not in sGrid: s=",sVal]; Interrupt[];Return[]];  sGridPosn = sGridPosn[[1,1]];  If[sGridPosn > 1 && sGridPosn < Length[sGrid],    (* then it's an intermediate point *)    PhitPrimeVal =       (      (PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn+1]],PermInc,QState,EmpState]      -PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState])      *((sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]])/(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]]))+      (PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState]      -PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn-1]],PermInc,QState,EmpState])      *((sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]])/(sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]]))      )      /(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn-1]]),    (* else *)      If[sGridPosn == 1,        (* then *)          PhitPrimeVal =            (PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn+1]],PermInc,QState,EmpState]           -PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn  ]],PermInc,QState,EmpState])           /(sGrid[[sGridPosn+1]]-sGrid[[sGridPosn]]),        (* else it's the last value in sGridPosn *)          PhitPrimeVal =            (PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn]],PermInc,QState,EmpState]           -PhitInterpFunc[[LifePosn]][sGrid[[sGridPosn-1]],PermInc,QState,EmpState])           /(sGrid[[sGridPosn]]-sGrid[[sGridPosn-1]])        ] (* End If sGridPosn     *)    ];    (* End If sGridPosn > 1 *)Return[PhitPrimeVal]]Remove[VtPrime];VtPrime[x_,PermInc_,QState_,EmpState_,LifePosn_] :=Block[{},  xGridPosn = Position[xGrid,x];  If[xGridPosn == {}, (* then *)  sVal = s; Print["VtPrime called with value of s not in xGrid: s=",sVal]; Interrupt[];Return[]];  xGridPosn = xGridPosn[[1,1]];  If[xGridPosn > 1 && xGridPosn < Length[xGrid],    (* then it's an intermediate point *)    VtPrimeVal =       (      (VtInterpFunc[[LifePosn]][xGrid[[xGridPosn+1]],PermInc,QState,EmpState]      -VtInterpFunc[[LifePosn]][xGrid[[xGridPosn  ]],PermInc,QState,EmpState])      *((xGrid[[xGridPosn]]-xGrid[[xGridPosn-1]])/(xGrid[[xGridPosn+1]]-xGrid[[xGridPosn]]))+      (VtInterpFunc[[LifePosn]][xGrid[[xGridPosn  ]],PermInc,QState,EmpState]      -VtInterpFunc[[LifePosn]][xGrid[[xGridPosn-1]],PermInc,QState,EmpState])      *((xGrid[[xGridPosn+1]]-xGrid[[xGridPosn]])/(xGrid[[xGridPosn]]-xGrid[[xGridPosn-1]]))      )      /(xGrid[[xGridPosn+1]]-xGrid[[xGridPosn-1]]),    (* else *)      If[xGridPosn == 1,        (* then *)          VtPrimeVal =            (VtInterpFunc[[LifePosn]][xGrid[[xGridPosn+1]],PermInc,QState,EmpState]           -VtInterpFunc[[LifePosn]][xGrid[[xGridPosn  ]],PermInc,QState,EmpState])           /(xGrid[[xGridPosn+1]]-xGrid[[xGridPosn]]),        (* else it's the last value in xGridPosn *)          VtPrimeVal =            (VtInterpFunc[[LifePosn]][xGrid[[xGridPosn]],PermInc,QState,EmpState]           -VtInterpFunc[[LifePosn]][xGrid[[xGridPosn-1]],PermInc,QState,EmpState])           /(xGrid[[xGridPosn]]-xGrid[[xGridPosn-1]])        ] (* End If xGridPosn     *)    ];    (* End If xGridPosn > 1 *)Return[VtPrimeVal]]ClearAll[KSharet];KSharet[x_,PermInc_,QState_,EmpState_,LifePosn_] :=Block[{},	KSharetOut = Chop[KSharetInterpFunc[[LifePosn]][x,PermInc,QState,EmpState]];	If[KSharetOut > 1, (* then *) KSharetOut = 1];	If[KSharetOut < 0, (* then *) KSharetOut = 0];	If[(0<KSharetOut) && (KSharetOut<KShareMin), KSharetOut = .1];	KSharetOut];ClearAll[RiskyShareKt];RiskyShareKt[x_,PermInc_,QState_,EmpState_,KSharet_,LifePosn_] :=Block[{},	RiskyShareKtOut =     	Chop[RiskyShareKtInterpFunc[[LifePosn]][x,PermInc,QState,EmpState,KSharet]];	If[RiskyShareKtOut > 1, (* then *) RiskyShareKtOut = 1];	If[RiskyShareKtOut < 0, (* then *) RiskyShareKtOut = 0];	RiskyShareKtOut];