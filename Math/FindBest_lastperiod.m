(*% This program defines the "pure" functions which return the value % of pursuing each of the possible housing options available at time LifePosn for % a given state. % FindBest requires several ambient variables to be defined.*)If[VerboseOutput == True,Print["Running FindBest.m"]];FindBest[[LifePosn,ChoiceBasic]] =Block[{ xt = #[[xtVtPos]],htStart = #[[htStartVtPos]],AggState=#[[AggStateVtPos]],EmpState=#[[EmpStateVtPos]],epDrawt=#[[epDrawtVtPos]]},  If[xt <= xmin,      (* then punish them for violating the liquidity constraint *)        RiskySharet=ct=zt=st=et=0;        vt= GreatBadness + beta[[LifePosn+1]] EtVtp1[st,hmin,AggState,EmpState,RiskySharet,LifePosn];,      (* else find the optimum *)      ctMultiplyFactor = htStart^-gamma G[[LifePosn,AggState]] epDrawt;      EtVtp1MultiplyFactor = (G[[LifePosn,AggState]] epDrawt)^((1-gamma)(1-rho));      htStartScaled = htStart/(G[[LifePosn,AggState]] epDrawt);      ct = xt;      RiskySharet = 0;      vt = ((ct ctMultiplyFactor)^(1-rho))/(1-rho);      htEnd = htStartScaled+catchup*(ct-htStartScaled epDrawt);      st = 0;    ]; (* End If[xt > xmin] *){vt,ChoiceBasic,ct,htEnd,st,RiskySharet}] &;